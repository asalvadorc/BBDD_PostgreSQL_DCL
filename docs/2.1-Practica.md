# ğŸ§ª PRÃCTICA: GestiÃ³n de Transacciones con TCL

## ğŸ¯ Objetivo

Aprender a:

- Utilizar **BEGIN / START TRANSACTION**
- Aplicar **COMMIT**
- Aplicar **ROLLBACK**
- Usar **SAVEPOINT**
- Entender la importancia de la atomicidad en bases de datos

---

## ğŸ—‚ï¸ Contexto

Trabajaremos con una base de datos de **ventas de entradas de cine**.

Cuando un cliente compra una entrada, deben realizarse varias acciones:

1. Registrar la compra  
2. Marcar el asiento como ocupado  
3. Reducir el nÃºmero de asientos disponibles  

âš ï¸ Todo esto debe hacerse como una Ãºnica unidad lÃ³gica.

---

# ğŸ—ï¸ PREPARACIÃ“N

## Crear tablas

```sql
CREATE TABLE Sesiones (
    id_sesion INT PRIMARY KEY,
    pelicula VARCHAR(50),
    asientos_disponibles INT
);

CREATE TABLE Asientos (
    id_asiento INT PRIMARY KEY,
    id_sesion INT,
    ocupado BOOLEAN
);

CREATE TABLE Ventas (
    id_venta INT PRIMARY KEY,
    id_sesion INT,
    id_asiento INT
);
```

## Insertar datos iniciales

```sql
INSERT INTO Sesiones VALUES (1, 'Avatar 3', 5);

INSERT INTO Asientos VALUES
(1,1,false),
(2,1,false),
(3,1,false),
(4,1,false),
(5,1,false);
```

---

# ğŸ§© PARTE 1 â€” Sin TransacciÃ³n (Para ver el problema)

Simular una compra SIN transacciÃ³n:

```sql
INSERT INTO Ventas VALUES (1,1,2);

UPDATE Asientos
SET ocupado = true
WHERE id_asiento = 2;

-- Simular fallo (NO ejecutar la siguiente lÃ­nea)

UPDATE Sesiones
SET asientos_disponibles = asientos_disponibles - 1
WHERE id_sesion = 1;
```

Consultar el estado:

```sql
SELECT * FROM Sesiones;
SELECT * FROM Asientos;
SELECT * FROM Ventas;
```

ğŸ“Œ **Pregunta:**  
Â¿Es consistente la base de datos?

---

# ğŸ§© PARTE 2 â€” Uso de BEGIN + COMMIT

```sql
START TRANSACTION;

INSERT INTO Ventas VALUES (2,1,3);

UPDATE Asientos
SET ocupado = true
WHERE id_asiento = 3;

UPDATE Sesiones
SET asientos_disponibles = asientos_disponibles - 1
WHERE id_sesion = 1;

COMMIT;
```

Consultar resultados:

```sql
SELECT * FROM Sesiones;
SELECT * FROM Asientos;
SELECT * FROM Ventas;
```

---

# ğŸ§© PARTE 3 â€” Uso de ROLLBACK

Simular un error:

```sql
START TRANSACTION;

INSERT INTO Ventas VALUES (3,1,4);

UPDATE Asientos
SET ocupado = true
WHERE id_asiento = 4;

-- ERROR SIMULADO â†’ sesiÃ³n no existe
UPDATE Sesiones
SET asientos_disponibles = asientos_disponibles - 1
WHERE id_sesion = 99;

ROLLBACK;
```

Consultar:

```sql
SELECT * FROM Sesiones;
SELECT * FROM Asientos;
SELECT * FROM Ventas;
```

ğŸ“Œ **Pregunta:**  
Â¿Se ha realizado alguna modificaciÃ³n?

---

# ğŸ§© PARTE 4 â€” Uso de SAVEPOINT

```sql
START TRANSACTION;

INSERT INTO Ventas VALUES (4,1,5);

SAVEPOINT venta_realizada;

UPDATE Asientos
SET ocupado = true
WHERE id_asiento = 5;

SAVEPOINT asiento_actualizado;

-- ERROR SIMULADO
UPDATE Sesiones
SET asientos_disponibles = asientos_disponibles - 1
WHERE id_sesion = 99;

ROLLBACK TO asiento_actualizado;

COMMIT;
```

Consultar:

```sql
SELECT * FROM Sesiones;
SELECT * FROM Asientos;
SELECT * FROM Ventas;
```

ğŸ“Œ **Pregunta:**  
Â¿QuÃ© cambios se han guardado?

---

# ğŸ§  PARTE 5 â€” ReflexiÃ³n

Responder:

1. Â¿QuÃ© ventaja tienen las transacciones?
2. Â¿QuÃ© ocurrirÃ­a en un sistema real sin ellas?
3. Â¿QuÃ© diferencia hay entre ROLLBACK y ROLLBACK TO SAVEPOINT?
4. Â¿En quÃ© situaciones reales usarÃ­as SAVEPOINT?

---

# ğŸ RETO FINAL

Crear una transacciÃ³n que:

- Venda **2 entradas a la vez**
- Si falla una, **no se venda ninguna**