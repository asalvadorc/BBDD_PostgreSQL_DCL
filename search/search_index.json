{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Bases de Dades","title":"Bases de Dades"},{"location":"#bases-de-dades","text":"","title":"Bases de Dades"},{"location":"1-DCLv2/","text":"El lenguaje de control de datos DCL El Data Control Language (DCL \u2013 Lenguaje de control de datos) se utiliza para gestionar los permisos y privilegios de acceso a los objetos dentro de una base de datos, estableciendo pol\u00edticas de seguridad que determinan qu\u00e9 usuarios o roles pueden interactuar con los datos y de qu\u00e9 manera. A trav\u00e9s del DCL, los administradores de bases de datos pueden otorgar o revocar permisos, asegurando que cada usuario solo pueda realizar las acciones que le han sido expresamente autorizadas. Este control es esencial para proteger la informaci\u00f3n sensible, evitar accesos no autorizados y mantener la integridad de los datos. Esquemas Cuando trabajamos con bases de datos en PostgreSQL, no todo est\u00e1 simplemente \u201cdentro\u201d de la base de datos sin orden. Existe un nivel intermedio de organizaci\u00f3n llamado esquema , que cumple una funci\u00f3n muy importante. Un esquema puede entenderse como una forma de estructurar y separar los distintos objetos que existen dentro de una misma base de datos. Es decir, las tablas, vistas, secuencias, funciones o tipos de datos no se guardan directamente en la base de datos, sino dentro de un esquema. Podemos imaginar la base de datos como si fuera un archivador grande. Dentro de ese archivador hay carpetas, y dentro de cada carpeta hay documentos. En este caso, las carpetas ser\u00edan los esquemas y los documentos ser\u00edan las tablas u otros objetos. Gracias a esto, es posible organizar la informaci\u00f3n seg\u00fan su funci\u00f3n. Adem\u00e1s de servir para organizar, los esquemas son fundamentales desde el punto de vista de la seguridad . En PostgreSQL, los permisos no se conceden \u00fanicamente sobre la base de datos en general, sino sobre elementos concretos. Y esos elementos se encuentran dentro de un esquema. Por tanto, si queremos controlar qui\u00e9n puede acceder a ciertas tablas, lo primero que necesitamos es tener claro en qu\u00e9 esquema se encuentran. Tambi\u00e9n es importante saber que PostgreSQL crea por defecto un esquema llamado public , que es donde se crean los objetos si no se indica ning\u00fan otro. Por eso, muchas veces trabajamos sin ser conscientes de que estamos usando un esquema, aunque realmente siempre existe. Resumen Los esquemas permiten organizar los objetos de una base de datos y establecer l\u00edmites claros de acceso. Por este motivo, antes de hablar de usuarios, grupos o roles, es conveniente entender qu\u00e9 son los esquemas, ya que los permisos que se asignan a esos usuarios se aplicar\u00e1n sobre los objetos contenidos en ellos. Usuarios, grupos y roles Una vez entendido que los objetos de una base de datos se organizan dentro de esquemas, el siguiente paso l\u00f3gico es plantearse qui\u00e9n puede acceder a esos objetos y qu\u00e9 puede hacer con ellos. Para ello, PostgreSQL utiliza un sistema de control de acceso basado en lo que denomina roles . A diferencia de otros sistemas gestores de bases de datos, PostgreSQL no distingue realmente entre usuarios y grupos como entidades diferentes. En su lugar, todo se gestiona mediante roles . Un rol puede comportarse como un usuario, como un grupo o como una combinaci\u00f3n de ambos, dependiendo de los permisos que tenga asignados. Un rol que tiene permiso para iniciar sesi\u00f3n en el sistema act\u00faa como un usuario. Es decir, representa a una persona o aplicaci\u00f3n que puede conectarse a la base de datos. Por otro lado, un rol que no tiene permiso de inicio de sesi\u00f3n puede utilizarse para agrupar permisos. En ese caso, funciona como un grupo. ROL PostgreSQL usa una \u00fanica figura llamada ROL , que puede comportarse como: Usuario \u2192 si puede iniciar sesi\u00f3n Grupo \u2192 si agrupa permisos Rol \u2192 si solo sirve para gestionar permisos Esto permite una gesti\u00f3n mucho m\u00e1s flexible de la seguridad . En lugar de asignar permisos directamente a cada usuario, lo habitual es crear roles que representen funciones dentro de la organizaci\u00f3n, como por ejemplo desarrolladores, administrativos o analistas. Despu\u00e9s, se asignan permisos a esos roles sobre determinados esquemas o tablas, y finalmente se asocian los usuarios a los roles correspondientes. De esta manera, cuando un usuario pasa a formar parte de un rol, hereda autom\u00e1ticamente todos los permisos que dicho rol tenga asignados. Si en alg\u00fan momento cambian las necesidades de acceso, basta con modificar los permisos del rol en lugar de hacerlo usuario por usuario. Este sistema simplifica enormemente la administraci\u00f3n de la seguridad, especialmente cuando el n\u00famero de usuarios crece. Adem\u00e1s, permite reflejar la estructura real de una organizaci\u00f3n dentro de la base de datos, separando claramente qui\u00e9n puede conectarse al sistema y qu\u00e9 puede hacer una vez dentro. Resumen En definitiva, los roles son el mecanismo que utiliza PostgreSQL para gestionar la autenticaci\u00f3n y los permisos. Gracias a ellos, es posible controlar el acceso a los distintos esquemas y objetos de forma organizada y escalable. Las instrucciones CREATE USER y CREATE GROUP son en realidad alias de la instrucci\u00f3n CREATE ROLE . Para crear un usuario de PostgreSQL, utilizaremos la siguiente instrucci\u00f3n SQL: CREATE USER myuser WITH PASSWORD 'passwd'; Tambi\u00e9n se podr\u00eda crear un usuario con la siguiente instrucci\u00f3n SQL: CREATE ROLE myuser WITH LOGIN PASSWORD \u2018passwd\u2019; Ambas sentencias crean exactamente el mismo usuario. Este nuevo usuario no tiene ning\u00fan permiso, a excepci\u00f3n de los permisos predeterminados disponibles para el rol public. Todos los nuevos usuarios y roles heredan los permisos del rol public. Un grupo es un rol que se usa para dar permisos a varios usuarios a la vez: CREATE ROLE mygroup; Luego a\u00f1adimos usuarios: GRANT mygroup TO myuser; Ahora myuser hereda permisos del grupo mygroup Seguridad El propietario de la base de datos es quien tiene todos los privilegios, pero no es el \u00fanico que accede a ella. A una base de datos pueden acceder muchas personas, que muchas veces quiz\u00e1 no tengan nada que ver entre s\u00ed o no se conozcan al realizar accesos remotos por diferentes motivos. Por ejemplo, a una base de datos con el stock de productos de una distribuidora con muchas tiendas ubicadas en distintas poblaciones podr\u00e1n acceder para manipular o consultar datos personas tan distintas como: Receptores de productos en los almacenes, para actualizar los stocks. Trabajadores para consultar si hay stock de un producto determinado. Las m\u00e1quinas registradoras , autom\u00e1ticamente, para actualizar el stock despu\u00e9s de una venta. Los encargados de compras , para consultar la situaci\u00f3n y tomar decisiones. Los trabajadores del departamento de control para tomar otro tipo de decisiones. Los clientes finales , desde sus casas, consultando si pueden ir a comprar ese producto determinado. Como se ve en esta situaci\u00f3n, pueden llegar a ser muchas las manos que accedan a los datos. Pero no ser\u00e1 lo mismo lo que debe poder ver un cliente final desde su casa que lo que debe ver un trabajador del departamento de control. Por esta raz\u00f3n, es importante asignar una serie de privilegios a los usuarios que acceden a los datos, de tal manera que cada usuario tenga un perfil asignado con unos permisos determinados sobre la base de datos, en global, y sobre las relaciones, en particular. La asignaci\u00f3n de los privilegios se puede llevar a cabo desde dos posibles puntos de vista: Desde el punto de vista del usuario. Desde el punto de vista de las tablas o las vistas. La sentencia que se utiliza en ambos casos para asignar permisos es la sentencia GRANT . Su sintaxis es: GRANT { <Privilegi1> [, < Privilegi2> ..] } | ALL ON [<User1>.]<Objecte> TO {<User2> [, <User3> ...]} | PUBLIC. Los privilegios pueden ser: ALL : asigna todos los permisos posibles a una tabla o a una vista. SELECT : asigna el permiso de realizar consultas (leer) a un usuario o sobre una tabla concreta. INSERT : asigna el permiso de inserci\u00f3n de datos a un usuario o sobre una tabla concreta. UPDATE : asigna el permiso de modificaci\u00f3n de datos a un usuario o sobre una tabla concreta. DELETE : asigna el permiso de borrado de datos a un usuario o sobre una tabla concreta. INDEX : asigna el permiso de creaci\u00f3n de \u00edndices para una tabla concreta o para un usuario. ALTER : asigna el permiso de modificaci\u00f3n de la estructura de una tabla o a un usuario. Un objeto puede ser una tabla o una vista. Un user se refiere a un usuario concreto. Por ejemplo: GRANT SELECT ON Productes TO Joan En este ejemplo se otorga el permiso de consulta al usuario Joan sobre la tabla Productos. La sentencia que se utiliza para quitar los permisos a un usuario determinado o sobre una tabla determinada es REVOKE. Su sintaxis es: REVOKE {ALL | SELECT | INSERT | DELETE | INDEX | ALTER | UPDATE | UPDATE(<Columna1> [, <Columna2> ...])} ON {<Tabla> | <Vista>} FROM {PUBLIC | <Usuario1> [, <Usuario2> ...]} {RESTRICT/CASCADE} Un ejemplo de utilizaci\u00f3n de la sentencia REVOKE es: REVOKE ALL ON Proveedores TO Joan En este caso, ahora se eliminan todos los privilegios sobre la tabla Proveedores al usuario Joan, que no podr\u00e1 ni acceder a registros de esta tabla, ni modificarlos, ni borrarlos. Las opciones RESTRICT/CASCADE permiten extender o detener la aplicaci\u00f3n de la sentencia REVOKE a lo largo de los usuarios a los que se hayan ido concediendo permisos. Es decir, si un usuario B dio permisos al usuario C para acceder a una tabla determinada y ahora el usuario B recibe una sentencia que revoca sus privilegios para acceder a esta tabla con la indicaci\u00f3n CASCADE, autom\u00e1ticamente el usuario C perder\u00e1 tambi\u00e9n los privilegios de acceso a dicha tabla. Esquema public y rol public Cuando creamos una nueva base de datos , PostgreSQL crea de forma predeterminada un esquema denominado public y concede acceso en este esquema a un rol de backend denominado public . A todos los usuarios y roles nuevos se les concede de forma predeterminada el rol public y, por lo tanto, pueden crear objetos en el esquema public. Si un usuario crea una tabla sin indicar el esquema, se guarda en public . Por defecto, todos los usuarios pueden crear objetos en este esquema, lo que impide tener usuarios realmente de solo lectura, ya que heredan ese permiso del rol public. Para solucionarlo, se debe revocar el permiso de creaci\u00f3n predeterminado en el esquema public desde el rol public mediante la siguiente instrucci\u00f3n SQL: REVOKE CREATE ON SCHEMA public FROM PUBLIC; Nos aseguraremos de ser el propietario del esquema public ha de formar parte de un rol que le permita ejecutar esta instrucci\u00f3n SQL. La siguiente declaraci\u00f3n revoca la capacidad del rol p\u00fablico de conectarse a la base de datos : REVOKE ALL ON DATABASE mydatabase FROM PUBLIC; Al quitar los permisos del rol public, los usuarios ya no podr\u00e1n conectarse ni crear objetos por defecto. Por eso, antes de hacerlo en producci\u00f3n, hay que dar permisos expl\u00edcitos a quienes s\u00ed los necesiten. Roles del sistema en PostgreSQL: los roles pg_... Al crear una instalaci\u00f3n de PostgreSQL, adem\u00e1s de los usuarios que el administrador pueda definir, el sistema incorpora autom\u00e1ticamente una serie de roles internos cuyos nombres comienzan por el prefijo pg_ . Estos roles no representan usuarios reales ni est\u00e1n pensados para iniciar sesi\u00f3n en la base de datos, sino que forman parte del propio mecanismo de seguridad del sistema. Estos roles se emplean asign\u00e1ndolos a otros usuarios o roles creados por el administrador. De este modo, es posible otorgar capacidades espec\u00edficas, como consultar informaci\u00f3n global o supervisar la actividad del servidor, sin necesidad de conceder privilegios de superusuario. Por tanto, su funci\u00f3n principal es servir como mecanismos de delegaci\u00f3n de permisos concretos. Gracias a ellos, se puede proporcionar a un usuario \u00fanicamente las capacidades necesarias para su trabajo, manteniendo al mismo tiempo un control m\u00e1s seguro sobre el sistema. En definitiva, los roles pg_ no se crean ni se alteran, sino que se utilizan mediante su asignaci\u00f3n a otros roles para distribuir privilegios de forma controlada. Crear roles de base de datos A continuaci\u00f3n, se detalla el proceso de creaci\u00f3n de nuevos roles y concesi\u00f3n de permisos para acceder a varios objetos de base de datos. Los permisos debemos concederlos a nivel de base de datos, esquema y objeto de esquema. Por ejemplo, si necesitamos conceder acceso a una tabla, tambi\u00e9n debemos asegurarnos de que el rol tenga acceso a la base de datos y al esquema en que existe la tabla. Si falta alguno de los permisos, el usuario/rol no podr\u00e1 acceder a la tabla. Rol de solo lectura El primer paso consiste en crear un nuevo rol denominado readonly mediante la siguiente instrucci\u00f3n SQL: CREATE ROLE readonly; Este es un rol simple sin permisos ni contrase\u00f1a. No se puede utilizar para iniciar sesi\u00f3n en la base de datos. Concedemos permiso a este rol para conectarse a la base de datos de destino denominada \"mydatabase\": GRANT CONNECT ON DATABASE mydatabase TO readonly; El siguiente paso es otorgar acceso al uso de este rol a su esquema. Supongamos que el esquema se llama \"myschema\": GRANT USAGE ON SCHEMA myschema TO readonly; En este paso se concede permiso de rol de readonly para realizar alguna actividad dentro del esquema. Sin este paso, el rol readonly no puede realizar ninguna acci\u00f3n en los objetos de este esquema, incluso si se han concedido permisos para esos objetos. El siguiente paso consiste en otorgar acceso al rol readonly para ejecutar las consultas en las tablas requeridas. GRANT SELECT ON TABLE mytable1, mytable2 TO readonly; Si el requisito es conceder acceso a todas las tablas y vistas del esquema, podemos utilizar el siguiente SQL: GRANT SELECT ON ALL TABLES IN SCHEMA myschema TO readonly; La instrucci\u00f3n SQL anterior otorga acceso SELECT al rol de solo lectura en todas las tablas y vistas existentes en el esquema llamado \"myschema\". Debemos tener en cuenta que el usuario readonly no podr\u00e1 acceder a las tablas nuevas que se a\u00f1adan en el futuro. Para garantizar que tambi\u00e9n pueda acceder a nuevas tablas y vistas, deberemos ejecutar la siguiente instrucci\u00f3n para conceder permisos autom\u00e1ticamente: ALTER DEFAULT PRIVILEGES IN SCHEMA myschema GRANT SELECT ON TABLES TO readonly; Rol de lectura y escritura El proceso de agregar un rol de lectura/escritura es muy similar al proceso de rol de solo lectura que se trat\u00f3 anteriormente. El primer paso es crear un rol: CREATE ROLE readwrite; Concedemos permiso a este rol para conectarse a la base de datos de destino: GRANT CONNECT ON DATABASE mydatabase TO readwrite; Concedemos privilegio de uso de esquemas: GRANT USAGE ON SCHEMA myschema TO readwrite; Si deseamos permitir que este rol cree nuevos objetos como tablas de este esquema, utilizaremos el siguiente SQL en lugar del anterior: GRANT USAGE, CREATE ON SCHEMA myschema TO readwrite; El siguiente paso ser\u00eda conceder acceso a las tablas. Como hemos comentado en la secci\u00f3n anterior, la concesi\u00f3n puede realizarse en tablas individuales o en todas las tablas del esquema. Para tablas individuales, utilizaremos el siguiente SQL: GRANT SELECT, INSERT, UPDATE, DELETE ON TABLE mytable1, mytable2 TO readwrite; Para todas las tablas y vistas del esquema: GRANT SELECT, INSERT, UPDATE, DELETE ON ALL TABLES IN SCHEMA myschema TO readwrite; Para conceder autom\u00e1ticamente permisos sobre tablas y vistas a\u00f1adidas en el futuro: ALTER DEFAULT PRIVILEGES IN SCHEMA myschema GRANT SELECT, INSERT, UPDATE, DELETE ON TABLES TO readwrite; Para los roles de lectura y escritura, normalmente existe el requisito de utilizar secuencias tambi\u00e9n. Podemos dar acceso selectivo de la siguiente manera: GRANT USAGE ON SEQUENCE myseq1, myseq2 TO readwrite; Tambi\u00e9n podemos conceder permiso a todas las secuencias mediante la siguiente instrucci\u00f3n SQL: GRANT USAGE ON ALL SEQUENCES IN SCHEMA myschema TO readwrite; Para conceder permisos autom\u00e1ticamente a las secuencias a\u00f1adidas en el futuro: ALTER DEFAULT PRIVILEGES IN SCHEMA myschema GRANT USAGE ON SEQUENCES TO readwrite; Podremos conceder m\u00e1s o menos permisos en funci\u00f3n de los requisitos. La documentaci\u00f3n del comando GRANT de PostgreSQL proporciona m\u00e1s detalles sobre los objetos en los que se pueden conceder permisos y las sentencias SQL necesarias. Creaci\u00f3n de usuarios de base de datos Con los roles implementados, se simplifica el proceso de creaci\u00f3n de usuarios. Simplemente crearemos el usuario y le concederemos uno de los roles existentes. Estas son las instrucciones SQL para este proceso: CREATE USER user1 WITH PASSWORD \u2018passwd\u2019; GRANT readonly TO user1; Esta instrucci\u00f3n SQL otorga a myuser1 los mismos permisos que el rol de solo lectura. Del mismo modo, podemos conceder acceso de lectura y escritura a un usuario otorgando el rol readwrite. La documentaci\u00f3n CREATE USER de PostgreSQL contiene m\u00e1s detalles sobre los par\u00e1metros que podemos establecer al crear un usuario. Por ejemplo, podemos especificar un plazo de caducidad para el usuario o permitir que el usuario cree bases de datos. Revocar o cambiar permisos Utilizando el m\u00e9todo detallado anteriormente, resulta muy f\u00e1cil revocar los privilegios de un usuario. Por ejemplo, podemos quitar el permiso de lectura y escritura (readwrite) de user1 utilizando la siguiente instrucci\u00f3n SQL: REVOKE readwrite FROM user1; Del mismo modo, podemos otorgar un nuevo rol de la siguiente manera: GRANT readonly TO user1; Comprobaci\u00f3n de roles concedidos Podemos utilizar la siguiente consulta para obtener una lista de todos los usuarios y roles de la base de datos junto con una lista de roles que se les han concedido: SELECT r.rolname, ARRAY(SELECT b.rolname FROM pg_catalog.pg_auth_members m JOIN pg_catalog.pg_roles b ON (m.roleid = b.oid) WHERE m.member = r.oid ) as memberof FROM pg_catalog.pg_roles r ORDER BY 1; Debemos tener en cuenta que un usuario puede ser miembro de varios roles con permisos distintos o superpuestos. En este caso, el usuario obtiene una suma de todos los permisos. Tambi\u00e9n se puede utilizar la tabla de cat\u00e1logo pg_roles para comprobar atributos como la fecha de caducidad de la contrase\u00f1a o el n\u00famero de conexiones paralelas permitidas.","title":"1. DCL"},{"location":"1-DCLv2/#el-lenguaje-de-control-de-datos-dcl","text":"El Data Control Language (DCL \u2013 Lenguaje de control de datos) se utiliza para gestionar los permisos y privilegios de acceso a los objetos dentro de una base de datos, estableciendo pol\u00edticas de seguridad que determinan qu\u00e9 usuarios o roles pueden interactuar con los datos y de qu\u00e9 manera. A trav\u00e9s del DCL, los administradores de bases de datos pueden otorgar o revocar permisos, asegurando que cada usuario solo pueda realizar las acciones que le han sido expresamente autorizadas. Este control es esencial para proteger la informaci\u00f3n sensible, evitar accesos no autorizados y mantener la integridad de los datos.","title":"El lenguaje de control de datos DCL"},{"location":"1-DCLv2/#esquemas","text":"Cuando trabajamos con bases de datos en PostgreSQL, no todo est\u00e1 simplemente \u201cdentro\u201d de la base de datos sin orden. Existe un nivel intermedio de organizaci\u00f3n llamado esquema , que cumple una funci\u00f3n muy importante. Un esquema puede entenderse como una forma de estructurar y separar los distintos objetos que existen dentro de una misma base de datos. Es decir, las tablas, vistas, secuencias, funciones o tipos de datos no se guardan directamente en la base de datos, sino dentro de un esquema. Podemos imaginar la base de datos como si fuera un archivador grande. Dentro de ese archivador hay carpetas, y dentro de cada carpeta hay documentos. En este caso, las carpetas ser\u00edan los esquemas y los documentos ser\u00edan las tablas u otros objetos. Gracias a esto, es posible organizar la informaci\u00f3n seg\u00fan su funci\u00f3n. Adem\u00e1s de servir para organizar, los esquemas son fundamentales desde el punto de vista de la seguridad . En PostgreSQL, los permisos no se conceden \u00fanicamente sobre la base de datos en general, sino sobre elementos concretos. Y esos elementos se encuentran dentro de un esquema. Por tanto, si queremos controlar qui\u00e9n puede acceder a ciertas tablas, lo primero que necesitamos es tener claro en qu\u00e9 esquema se encuentran. Tambi\u00e9n es importante saber que PostgreSQL crea por defecto un esquema llamado public , que es donde se crean los objetos si no se indica ning\u00fan otro. Por eso, muchas veces trabajamos sin ser conscientes de que estamos usando un esquema, aunque realmente siempre existe. Resumen Los esquemas permiten organizar los objetos de una base de datos y establecer l\u00edmites claros de acceso. Por este motivo, antes de hablar de usuarios, grupos o roles, es conveniente entender qu\u00e9 son los esquemas, ya que los permisos que se asignan a esos usuarios se aplicar\u00e1n sobre los objetos contenidos en ellos.","title":"Esquemas"},{"location":"1-DCLv2/#usuarios-grupos-y-roles","text":"Una vez entendido que los objetos de una base de datos se organizan dentro de esquemas, el siguiente paso l\u00f3gico es plantearse qui\u00e9n puede acceder a esos objetos y qu\u00e9 puede hacer con ellos. Para ello, PostgreSQL utiliza un sistema de control de acceso basado en lo que denomina roles . A diferencia de otros sistemas gestores de bases de datos, PostgreSQL no distingue realmente entre usuarios y grupos como entidades diferentes. En su lugar, todo se gestiona mediante roles . Un rol puede comportarse como un usuario, como un grupo o como una combinaci\u00f3n de ambos, dependiendo de los permisos que tenga asignados. Un rol que tiene permiso para iniciar sesi\u00f3n en el sistema act\u00faa como un usuario. Es decir, representa a una persona o aplicaci\u00f3n que puede conectarse a la base de datos. Por otro lado, un rol que no tiene permiso de inicio de sesi\u00f3n puede utilizarse para agrupar permisos. En ese caso, funciona como un grupo. ROL PostgreSQL usa una \u00fanica figura llamada ROL , que puede comportarse como: Usuario \u2192 si puede iniciar sesi\u00f3n Grupo \u2192 si agrupa permisos Rol \u2192 si solo sirve para gestionar permisos Esto permite una gesti\u00f3n mucho m\u00e1s flexible de la seguridad . En lugar de asignar permisos directamente a cada usuario, lo habitual es crear roles que representen funciones dentro de la organizaci\u00f3n, como por ejemplo desarrolladores, administrativos o analistas. Despu\u00e9s, se asignan permisos a esos roles sobre determinados esquemas o tablas, y finalmente se asocian los usuarios a los roles correspondientes. De esta manera, cuando un usuario pasa a formar parte de un rol, hereda autom\u00e1ticamente todos los permisos que dicho rol tenga asignados. Si en alg\u00fan momento cambian las necesidades de acceso, basta con modificar los permisos del rol en lugar de hacerlo usuario por usuario. Este sistema simplifica enormemente la administraci\u00f3n de la seguridad, especialmente cuando el n\u00famero de usuarios crece. Adem\u00e1s, permite reflejar la estructura real de una organizaci\u00f3n dentro de la base de datos, separando claramente qui\u00e9n puede conectarse al sistema y qu\u00e9 puede hacer una vez dentro. Resumen En definitiva, los roles son el mecanismo que utiliza PostgreSQL para gestionar la autenticaci\u00f3n y los permisos. Gracias a ellos, es posible controlar el acceso a los distintos esquemas y objetos de forma organizada y escalable. Las instrucciones CREATE USER y CREATE GROUP son en realidad alias de la instrucci\u00f3n CREATE ROLE . Para crear un usuario de PostgreSQL, utilizaremos la siguiente instrucci\u00f3n SQL: CREATE USER myuser WITH PASSWORD 'passwd'; Tambi\u00e9n se podr\u00eda crear un usuario con la siguiente instrucci\u00f3n SQL: CREATE ROLE myuser WITH LOGIN PASSWORD \u2018passwd\u2019; Ambas sentencias crean exactamente el mismo usuario. Este nuevo usuario no tiene ning\u00fan permiso, a excepci\u00f3n de los permisos predeterminados disponibles para el rol public. Todos los nuevos usuarios y roles heredan los permisos del rol public. Un grupo es un rol que se usa para dar permisos a varios usuarios a la vez: CREATE ROLE mygroup; Luego a\u00f1adimos usuarios: GRANT mygroup TO myuser; Ahora myuser hereda permisos del grupo mygroup","title":"Usuarios, grupos y roles"},{"location":"1-DCLv2/#seguridad","text":"El propietario de la base de datos es quien tiene todos los privilegios, pero no es el \u00fanico que accede a ella. A una base de datos pueden acceder muchas personas, que muchas veces quiz\u00e1 no tengan nada que ver entre s\u00ed o no se conozcan al realizar accesos remotos por diferentes motivos. Por ejemplo, a una base de datos con el stock de productos de una distribuidora con muchas tiendas ubicadas en distintas poblaciones podr\u00e1n acceder para manipular o consultar datos personas tan distintas como: Receptores de productos en los almacenes, para actualizar los stocks. Trabajadores para consultar si hay stock de un producto determinado. Las m\u00e1quinas registradoras , autom\u00e1ticamente, para actualizar el stock despu\u00e9s de una venta. Los encargados de compras , para consultar la situaci\u00f3n y tomar decisiones. Los trabajadores del departamento de control para tomar otro tipo de decisiones. Los clientes finales , desde sus casas, consultando si pueden ir a comprar ese producto determinado. Como se ve en esta situaci\u00f3n, pueden llegar a ser muchas las manos que accedan a los datos. Pero no ser\u00e1 lo mismo lo que debe poder ver un cliente final desde su casa que lo que debe ver un trabajador del departamento de control. Por esta raz\u00f3n, es importante asignar una serie de privilegios a los usuarios que acceden a los datos, de tal manera que cada usuario tenga un perfil asignado con unos permisos determinados sobre la base de datos, en global, y sobre las relaciones, en particular. La asignaci\u00f3n de los privilegios se puede llevar a cabo desde dos posibles puntos de vista: Desde el punto de vista del usuario. Desde el punto de vista de las tablas o las vistas. La sentencia que se utiliza en ambos casos para asignar permisos es la sentencia GRANT . Su sintaxis es: GRANT { <Privilegi1> [, < Privilegi2> ..] } | ALL ON [<User1>.]<Objecte> TO {<User2> [, <User3> ...]} | PUBLIC. Los privilegios pueden ser: ALL : asigna todos los permisos posibles a una tabla o a una vista. SELECT : asigna el permiso de realizar consultas (leer) a un usuario o sobre una tabla concreta. INSERT : asigna el permiso de inserci\u00f3n de datos a un usuario o sobre una tabla concreta. UPDATE : asigna el permiso de modificaci\u00f3n de datos a un usuario o sobre una tabla concreta. DELETE : asigna el permiso de borrado de datos a un usuario o sobre una tabla concreta. INDEX : asigna el permiso de creaci\u00f3n de \u00edndices para una tabla concreta o para un usuario. ALTER : asigna el permiso de modificaci\u00f3n de la estructura de una tabla o a un usuario. Un objeto puede ser una tabla o una vista. Un user se refiere a un usuario concreto. Por ejemplo: GRANT SELECT ON Productes TO Joan En este ejemplo se otorga el permiso de consulta al usuario Joan sobre la tabla Productos. La sentencia que se utiliza para quitar los permisos a un usuario determinado o sobre una tabla determinada es REVOKE. Su sintaxis es: REVOKE {ALL | SELECT | INSERT | DELETE | INDEX | ALTER | UPDATE | UPDATE(<Columna1> [, <Columna2> ...])} ON {<Tabla> | <Vista>} FROM {PUBLIC | <Usuario1> [, <Usuario2> ...]} {RESTRICT/CASCADE} Un ejemplo de utilizaci\u00f3n de la sentencia REVOKE es: REVOKE ALL ON Proveedores TO Joan En este caso, ahora se eliminan todos los privilegios sobre la tabla Proveedores al usuario Joan, que no podr\u00e1 ni acceder a registros de esta tabla, ni modificarlos, ni borrarlos. Las opciones RESTRICT/CASCADE permiten extender o detener la aplicaci\u00f3n de la sentencia REVOKE a lo largo de los usuarios a los que se hayan ido concediendo permisos. Es decir, si un usuario B dio permisos al usuario C para acceder a una tabla determinada y ahora el usuario B recibe una sentencia que revoca sus privilegios para acceder a esta tabla con la indicaci\u00f3n CASCADE, autom\u00e1ticamente el usuario C perder\u00e1 tambi\u00e9n los privilegios de acceso a dicha tabla.","title":"Seguridad"},{"location":"1-DCLv2/#esquema-public-y-rol-public","text":"Cuando creamos una nueva base de datos , PostgreSQL crea de forma predeterminada un esquema denominado public y concede acceso en este esquema a un rol de backend denominado public . A todos los usuarios y roles nuevos se les concede de forma predeterminada el rol public y, por lo tanto, pueden crear objetos en el esquema public. Si un usuario crea una tabla sin indicar el esquema, se guarda en public . Por defecto, todos los usuarios pueden crear objetos en este esquema, lo que impide tener usuarios realmente de solo lectura, ya que heredan ese permiso del rol public. Para solucionarlo, se debe revocar el permiso de creaci\u00f3n predeterminado en el esquema public desde el rol public mediante la siguiente instrucci\u00f3n SQL: REVOKE CREATE ON SCHEMA public FROM PUBLIC; Nos aseguraremos de ser el propietario del esquema public ha de formar parte de un rol que le permita ejecutar esta instrucci\u00f3n SQL. La siguiente declaraci\u00f3n revoca la capacidad del rol p\u00fablico de conectarse a la base de datos : REVOKE ALL ON DATABASE mydatabase FROM PUBLIC; Al quitar los permisos del rol public, los usuarios ya no podr\u00e1n conectarse ni crear objetos por defecto. Por eso, antes de hacerlo en producci\u00f3n, hay que dar permisos expl\u00edcitos a quienes s\u00ed los necesiten.","title":"Esquema public y rol public"},{"location":"1-DCLv2/#roles-del-sistema-en-postgresql-los-roles-pg_","text":"Al crear una instalaci\u00f3n de PostgreSQL, adem\u00e1s de los usuarios que el administrador pueda definir, el sistema incorpora autom\u00e1ticamente una serie de roles internos cuyos nombres comienzan por el prefijo pg_ . Estos roles no representan usuarios reales ni est\u00e1n pensados para iniciar sesi\u00f3n en la base de datos, sino que forman parte del propio mecanismo de seguridad del sistema. Estos roles se emplean asign\u00e1ndolos a otros usuarios o roles creados por el administrador. De este modo, es posible otorgar capacidades espec\u00edficas, como consultar informaci\u00f3n global o supervisar la actividad del servidor, sin necesidad de conceder privilegios de superusuario. Por tanto, su funci\u00f3n principal es servir como mecanismos de delegaci\u00f3n de permisos concretos. Gracias a ellos, se puede proporcionar a un usuario \u00fanicamente las capacidades necesarias para su trabajo, manteniendo al mismo tiempo un control m\u00e1s seguro sobre el sistema. En definitiva, los roles pg_ no se crean ni se alteran, sino que se utilizan mediante su asignaci\u00f3n a otros roles para distribuir privilegios de forma controlada.","title":"Roles del sistema en PostgreSQL: los roles pg_..."},{"location":"1-DCLv2/#crear-roles-de-base-de-datos","text":"A continuaci\u00f3n, se detalla el proceso de creaci\u00f3n de nuevos roles y concesi\u00f3n de permisos para acceder a varios objetos de base de datos. Los permisos debemos concederlos a nivel de base de datos, esquema y objeto de esquema. Por ejemplo, si necesitamos conceder acceso a una tabla, tambi\u00e9n debemos asegurarnos de que el rol tenga acceso a la base de datos y al esquema en que existe la tabla. Si falta alguno de los permisos, el usuario/rol no podr\u00e1 acceder a la tabla.","title":"Crear roles de base de datos"},{"location":"1-DCLv2/#rol-de-solo-lectura","text":"El primer paso consiste en crear un nuevo rol denominado readonly mediante la siguiente instrucci\u00f3n SQL: CREATE ROLE readonly; Este es un rol simple sin permisos ni contrase\u00f1a. No se puede utilizar para iniciar sesi\u00f3n en la base de datos. Concedemos permiso a este rol para conectarse a la base de datos de destino denominada \"mydatabase\": GRANT CONNECT ON DATABASE mydatabase TO readonly; El siguiente paso es otorgar acceso al uso de este rol a su esquema. Supongamos que el esquema se llama \"myschema\": GRANT USAGE ON SCHEMA myschema TO readonly; En este paso se concede permiso de rol de readonly para realizar alguna actividad dentro del esquema. Sin este paso, el rol readonly no puede realizar ninguna acci\u00f3n en los objetos de este esquema, incluso si se han concedido permisos para esos objetos. El siguiente paso consiste en otorgar acceso al rol readonly para ejecutar las consultas en las tablas requeridas. GRANT SELECT ON TABLE mytable1, mytable2 TO readonly; Si el requisito es conceder acceso a todas las tablas y vistas del esquema, podemos utilizar el siguiente SQL: GRANT SELECT ON ALL TABLES IN SCHEMA myschema TO readonly; La instrucci\u00f3n SQL anterior otorga acceso SELECT al rol de solo lectura en todas las tablas y vistas existentes en el esquema llamado \"myschema\". Debemos tener en cuenta que el usuario readonly no podr\u00e1 acceder a las tablas nuevas que se a\u00f1adan en el futuro. Para garantizar que tambi\u00e9n pueda acceder a nuevas tablas y vistas, deberemos ejecutar la siguiente instrucci\u00f3n para conceder permisos autom\u00e1ticamente: ALTER DEFAULT PRIVILEGES IN SCHEMA myschema GRANT SELECT ON TABLES TO readonly;","title":"Rol de solo lectura"},{"location":"1-DCLv2/#rol-de-lectura-y-escritura","text":"El proceso de agregar un rol de lectura/escritura es muy similar al proceso de rol de solo lectura que se trat\u00f3 anteriormente. El primer paso es crear un rol: CREATE ROLE readwrite; Concedemos permiso a este rol para conectarse a la base de datos de destino: GRANT CONNECT ON DATABASE mydatabase TO readwrite; Concedemos privilegio de uso de esquemas: GRANT USAGE ON SCHEMA myschema TO readwrite; Si deseamos permitir que este rol cree nuevos objetos como tablas de este esquema, utilizaremos el siguiente SQL en lugar del anterior: GRANT USAGE, CREATE ON SCHEMA myschema TO readwrite; El siguiente paso ser\u00eda conceder acceso a las tablas. Como hemos comentado en la secci\u00f3n anterior, la concesi\u00f3n puede realizarse en tablas individuales o en todas las tablas del esquema. Para tablas individuales, utilizaremos el siguiente SQL: GRANT SELECT, INSERT, UPDATE, DELETE ON TABLE mytable1, mytable2 TO readwrite; Para todas las tablas y vistas del esquema: GRANT SELECT, INSERT, UPDATE, DELETE ON ALL TABLES IN SCHEMA myschema TO readwrite; Para conceder autom\u00e1ticamente permisos sobre tablas y vistas a\u00f1adidas en el futuro: ALTER DEFAULT PRIVILEGES IN SCHEMA myschema GRANT SELECT, INSERT, UPDATE, DELETE ON TABLES TO readwrite; Para los roles de lectura y escritura, normalmente existe el requisito de utilizar secuencias tambi\u00e9n. Podemos dar acceso selectivo de la siguiente manera: GRANT USAGE ON SEQUENCE myseq1, myseq2 TO readwrite; Tambi\u00e9n podemos conceder permiso a todas las secuencias mediante la siguiente instrucci\u00f3n SQL: GRANT USAGE ON ALL SEQUENCES IN SCHEMA myschema TO readwrite; Para conceder permisos autom\u00e1ticamente a las secuencias a\u00f1adidas en el futuro: ALTER DEFAULT PRIVILEGES IN SCHEMA myschema GRANT USAGE ON SEQUENCES TO readwrite; Podremos conceder m\u00e1s o menos permisos en funci\u00f3n de los requisitos. La documentaci\u00f3n del comando GRANT de PostgreSQL proporciona m\u00e1s detalles sobre los objetos en los que se pueden conceder permisos y las sentencias SQL necesarias.","title":"Rol de lectura y escritura"},{"location":"1-DCLv2/#creacion-de-usuarios-de-base-de-datos","text":"Con los roles implementados, se simplifica el proceso de creaci\u00f3n de usuarios. Simplemente crearemos el usuario y le concederemos uno de los roles existentes. Estas son las instrucciones SQL para este proceso: CREATE USER user1 WITH PASSWORD \u2018passwd\u2019; GRANT readonly TO user1; Esta instrucci\u00f3n SQL otorga a myuser1 los mismos permisos que el rol de solo lectura. Del mismo modo, podemos conceder acceso de lectura y escritura a un usuario otorgando el rol readwrite. La documentaci\u00f3n CREATE USER de PostgreSQL contiene m\u00e1s detalles sobre los par\u00e1metros que podemos establecer al crear un usuario. Por ejemplo, podemos especificar un plazo de caducidad para el usuario o permitir que el usuario cree bases de datos.","title":"Creaci\u00f3n de usuarios de base de datos"},{"location":"1-DCLv2/#revocar-o-cambiar-permisos","text":"Utilizando el m\u00e9todo detallado anteriormente, resulta muy f\u00e1cil revocar los privilegios de un usuario. Por ejemplo, podemos quitar el permiso de lectura y escritura (readwrite) de user1 utilizando la siguiente instrucci\u00f3n SQL: REVOKE readwrite FROM user1; Del mismo modo, podemos otorgar un nuevo rol de la siguiente manera: GRANT readonly TO user1;","title":"Revocar o cambiar permisos"},{"location":"1-DCLv2/#comprobacion-de-roles-concedidos","text":"Podemos utilizar la siguiente consulta para obtener una lista de todos los usuarios y roles de la base de datos junto con una lista de roles que se les han concedido: SELECT r.rolname, ARRAY(SELECT b.rolname FROM pg_catalog.pg_auth_members m JOIN pg_catalog.pg_roles b ON (m.roleid = b.oid) WHERE m.member = r.oid ) as memberof FROM pg_catalog.pg_roles r ORDER BY 1; Debemos tener en cuenta que un usuario puede ser miembro de varios roles con permisos distintos o superpuestos. En este caso, el usuario obtiene una suma de todos los permisos. Tambi\u00e9n se puede utilizar la tabla de cat\u00e1logo pg_roles para comprobar atributos como la fecha de caducidad de la contrase\u00f1a o el n\u00famero de conexiones paralelas permitidas.","title":"Comprobaci\u00f3n de roles concedidos"},{"location":"1.1-Practica/","text":"\ud83d\uded2 PR\u00c1CTICA DCL POSTGRESQL Gesti\u00f3n de usuarios, roles y permisos En esta pr\u00e1ctica vas a dise\u00f1ar un sistema de control de acceso para una base de datos de una tienda utilizando roles y permisos en PostgreSQL. El objetivo es que cada tipo de usuario solo pueda realizar las operaciones que le correspondan seg\u00fan su funci\u00f3n. \ud83c\udfaf Objetivos Crear una base de datos con un esquema propio Gestionar roles como grupos de permisos Asignar permisos sobre tablas Asociar usuarios a roles Comprobar que cada usuario solo puede hacer lo que le corresponde \ud83e\uddf1 1. Crear la base de datos Crea una base de datos llamada: tienda y con\u00e9ctate a ella. \ud83d\udcc1 2. Crear un esquema propio Crea un esquema llamado: app \ud83d\udd12 3. Seguridad b\u00e1sica Impide que cualquier usuario pueda crear objetos en el esquema public . \ud83d\udce6 4. Crear las tablas Dentro del esquema app , crea: Tabla productos Debe contener: id: SERIAL nombre: VARCHAR(50), no nulo stock: INT, no nulo, Por defecto 0 Tabla ventas Debe contener: id: SERIAL producto_id: no nulo, FK Productos unidades: INT no nulo fech: DATE, no nulo, por defecto Now() Insertar Datos Inserta algunos registros de prueba en las dos tablas. \ud83d\udc65 5. Crear los roles (grupos) Crea los siguientes roles: rol_consulta rol_almacen rol_tpvs rol_admin \ud83d\udd11 6. Permitir acceso al esquema Todos los roles deben poder acceder al esquema app . \ud83d\udee0\ufe0f 7. Asignar permisos seg\u00fan funci\u00f3n Cada rol debe tener los siguientes permisos: \ud83d\udd0d rol_consulta Solo puede consultar productos \ud83d\udce6 rol_almacen Puede consultar productos Puede actualizar el stock \ud83d\uded2 rol_tpvs Puede consultar productos Puede registrar ventas \ud83d\udc51 rol_admin Debe tener control total sobre las tablas del esquema \ud83d\udd04 8. Secuencias Aseg\u00farate de que los roles que insertan datos puedan usar las secuencias necesarias. \ud83d\udc64 9. Crear usuarios Crea los siguientes usuarios: user_consulta user_almacen user_tpvs user_admin \ud83d\udd17 10. Asociar usuarios a roles Cada usuario debe pertenecer a su rol correspondiente. \ud83e\uddea 11. Pruebas Comprueba el comportamiento conect\u00e1ndote como cada usuario. \ud83d\udd0d user_consulta Debe poder: Consultar productos No debe poder: Modificar stock Insertar ventas \ud83d\udce6 user_almacen Debe poder: Consultar productos Actualizar stock No debe poder: Registrar ventas \ud83d\uded2 user_tpvs Debe poder: Consultar productos Insertar ventas No debe poder: Modificar stock \ud83d\udc51 user_admin Debe poder: Consultar Insertar Modificar Borrar \ud83d\udd75\ufe0f 12. Usuario auditor Crea un usuario que: No pertenezca a ning\u00fan rol creado Pueda leer todos los datos No pueda modificarlos \ud83e\uddf0 13. Verificaci\u00f3n Comprueba los permisos existentes sobre las tablas.","title":"1.1 Pr\u00e1ctica"},{"location":"1.1-Practica/#practica-dcl-postgresql","text":"Gesti\u00f3n de usuarios, roles y permisos En esta pr\u00e1ctica vas a dise\u00f1ar un sistema de control de acceso para una base de datos de una tienda utilizando roles y permisos en PostgreSQL. El objetivo es que cada tipo de usuario solo pueda realizar las operaciones que le correspondan seg\u00fan su funci\u00f3n. \ud83c\udfaf Objetivos Crear una base de datos con un esquema propio Gestionar roles como grupos de permisos Asignar permisos sobre tablas Asociar usuarios a roles Comprobar que cada usuario solo puede hacer lo que le corresponde","title":"\ud83d\uded2 PR\u00c1CTICA DCL POSTGRESQL"},{"location":"1.1-Practica/#1-crear-la-base-de-datos","text":"Crea una base de datos llamada: tienda y con\u00e9ctate a ella.","title":"\ud83e\uddf1 1. Crear la base de datos"},{"location":"1.1-Practica/#2-crear-un-esquema-propio","text":"Crea un esquema llamado: app","title":"\ud83d\udcc1 2. Crear un esquema propio"},{"location":"1.1-Practica/#3-seguridad-basica","text":"Impide que cualquier usuario pueda crear objetos en el esquema public .","title":"\ud83d\udd12 3. Seguridad b\u00e1sica"},{"location":"1.1-Practica/#4-crear-las-tablas","text":"Dentro del esquema app , crea:","title":"\ud83d\udce6 4. Crear las tablas"},{"location":"1.1-Practica/#tabla-productos","text":"Debe contener: id: SERIAL nombre: VARCHAR(50), no nulo stock: INT, no nulo, Por defecto 0","title":"Tabla productos"},{"location":"1.1-Practica/#tabla-ventas","text":"Debe contener: id: SERIAL producto_id: no nulo, FK Productos unidades: INT no nulo fech: DATE, no nulo, por defecto Now()","title":"Tabla ventas"},{"location":"1.1-Practica/#insertar-datos","text":"Inserta algunos registros de prueba en las dos tablas.","title":"Insertar Datos"},{"location":"1.1-Practica/#5-crear-los-roles-grupos","text":"Crea los siguientes roles: rol_consulta rol_almacen rol_tpvs rol_admin","title":"\ud83d\udc65 5. Crear los roles (grupos)"},{"location":"1.1-Practica/#6-permitir-acceso-al-esquema","text":"Todos los roles deben poder acceder al esquema app .","title":"\ud83d\udd11 6. Permitir acceso al esquema"},{"location":"1.1-Practica/#7-asignar-permisos-segun-funcion","text":"Cada rol debe tener los siguientes permisos:","title":"\ud83d\udee0\ufe0f 7. Asignar permisos seg\u00fan funci\u00f3n"},{"location":"1.1-Practica/#rol_consulta","text":"Solo puede consultar productos","title":"\ud83d\udd0d rol_consulta"},{"location":"1.1-Practica/#rol_almacen","text":"Puede consultar productos Puede actualizar el stock","title":"\ud83d\udce6 rol_almacen"},{"location":"1.1-Practica/#rol_tpvs","text":"Puede consultar productos Puede registrar ventas","title":"\ud83d\uded2 rol_tpvs"},{"location":"1.1-Practica/#rol_admin","text":"Debe tener control total sobre las tablas del esquema","title":"\ud83d\udc51 rol_admin"},{"location":"1.1-Practica/#8-secuencias","text":"Aseg\u00farate de que los roles que insertan datos puedan usar las secuencias necesarias.","title":"\ud83d\udd04 8. Secuencias"},{"location":"1.1-Practica/#9-crear-usuarios","text":"Crea los siguientes usuarios: user_consulta user_almacen user_tpvs user_admin","title":"\ud83d\udc64 9. Crear usuarios"},{"location":"1.1-Practica/#10-asociar-usuarios-a-roles","text":"Cada usuario debe pertenecer a su rol correspondiente.","title":"\ud83d\udd17 10. Asociar usuarios a roles"},{"location":"1.1-Practica/#11-pruebas","text":"Comprueba el comportamiento conect\u00e1ndote como cada usuario.","title":"\ud83e\uddea 11. Pruebas"},{"location":"1.1-Practica/#user_consulta","text":"Debe poder: Consultar productos No debe poder: Modificar stock Insertar ventas","title":"\ud83d\udd0d user_consulta"},{"location":"1.1-Practica/#user_almacen","text":"Debe poder: Consultar productos Actualizar stock No debe poder: Registrar ventas","title":"\ud83d\udce6 user_almacen"},{"location":"1.1-Practica/#user_tpvs","text":"Debe poder: Consultar productos Insertar ventas No debe poder: Modificar stock","title":"\ud83d\uded2 user_tpvs"},{"location":"1.1-Practica/#user_admin","text":"Debe poder: Consultar Insertar Modificar Borrar","title":"\ud83d\udc51 user_admin"},{"location":"1.1-Practica/#12-usuario-auditor","text":"Crea un usuario que: No pertenezca a ning\u00fan rol creado Pueda leer todos los datos No pueda modificarlos","title":"\ud83d\udd75\ufe0f 12. Usuario auditor"},{"location":"1.1-Practica/#13-verificacion","text":"Comprueba los permisos existentes sobre las tablas.","title":"\ud83e\uddf0 13. Verificaci\u00f3n"},{"location":"1_introducci/","text":"1. Introducci\u00f3 Llenguatge de control de dades (DCL, data control language*) , \u00e9s l\u2019encarregat d\u2019establir els mecanismes de control. Ofereix solucions als problemes de concurr\u00e8ncia dels usuaris i garanteix la seguretat de les dades. El llenguatge SQL \u00e9s un llenguatge declaratiu, \u00e9s a dir, no \u00e9s imperatiu o procedimental. El llenguatge SQL indicar\u00e0 qu\u00e8 es vol fer, no indicar\u00e0 com s\u2019ha de fer. Per aquesta ra\u00f3, necessita al seu costat un altre llenguatge s\u00ed procedimental que doni les instruccions al sistema per fer una s\u00e8rie d\u2019operacions. Aquest apartat se centra en el llenguatge de control de dades (DCL). S\u2019encarrega de totes les instruccions que tenen a veure amb l\u2019administraci\u00f3 de la base de dades: creaci\u00f3 d\u2019usuaris, assignaci\u00f3 de privilegis, accessos, tunning , \u2026 Aquest llenguatge pot resumir les seves funcionalitats en dues: 1) Oferir accions per dur a terme transaccions 2) Oferir solucions per garantir la seguretat de les dades. Aquestes dues funcionalitats s\u00f3n clau per solucionar els problemes d\u2019una de les caracter\u00edstiques m\u00e9s importants d\u2019una base de dades: la capacitat de ser-ne multiusuari. L\u2019acc\u00e9s com\u00fa de diversos usuaris a les mateixes dades pot donar peu a problemes molt importants, com el problema de la protecci\u00f3 de dades i l\u2019assignaci\u00f3 posterior de privilegis. Per tant, requereix un tractament especial. Les dues funcionalitats estan directament relacionades amb els conceptes de confidencialitat , integritat i disponibilitat : Amb la possibilitat de donar permisos als usuaris per accedir a part de la informaci\u00f3 s\u2019ofereix una soluci\u00f3 al problema de la confidencialitat. Amb la possibilitat de dur a terme execucions de consultes ( query ) a partir de transaccions s\u2019ofereixen solucions als problemes d\u2019integritat i disponibilitat.","title":"0. Introducci\u00f3n"},{"location":"1_introducci/#1-introduccio","text":"Llenguatge de control de dades (DCL, data control language*) , \u00e9s l\u2019encarregat d\u2019establir els mecanismes de control. Ofereix solucions als problemes de concurr\u00e8ncia dels usuaris i garanteix la seguretat de les dades. El llenguatge SQL \u00e9s un llenguatge declaratiu, \u00e9s a dir, no \u00e9s imperatiu o procedimental. El llenguatge SQL indicar\u00e0 qu\u00e8 es vol fer, no indicar\u00e0 com s\u2019ha de fer. Per aquesta ra\u00f3, necessita al seu costat un altre llenguatge s\u00ed procedimental que doni les instruccions al sistema per fer una s\u00e8rie d\u2019operacions. Aquest apartat se centra en el llenguatge de control de dades (DCL). S\u2019encarrega de totes les instruccions que tenen a veure amb l\u2019administraci\u00f3 de la base de dades: creaci\u00f3 d\u2019usuaris, assignaci\u00f3 de privilegis, accessos, tunning , \u2026 Aquest llenguatge pot resumir les seves funcionalitats en dues: 1) Oferir accions per dur a terme transaccions 2) Oferir solucions per garantir la seguretat de les dades. Aquestes dues funcionalitats s\u00f3n clau per solucionar els problemes d\u2019una de les caracter\u00edstiques m\u00e9s importants d\u2019una base de dades: la capacitat de ser-ne multiusuari. L\u2019acc\u00e9s com\u00fa de diversos usuaris a les mateixes dades pot donar peu a problemes molt importants, com el problema de la protecci\u00f3 de dades i l\u2019assignaci\u00f3 posterior de privilegis. Per tant, requereix un tractament especial. Les dues funcionalitats estan directament relacionades amb els conceptes de confidencialitat , integritat i disponibilitat : Amb la possibilitat de donar permisos als usuaris per accedir a part de la informaci\u00f3 s\u2019ofereix una soluci\u00f3 al problema de la confidencialitat. Amb la possibilitat de dur a terme execucions de consultes ( query ) a partir de transaccions s\u2019ofereixen solucions als problemes d\u2019integritat i disponibilitat.","title":"1. Introducci\u00f3"},{"location":"2-TCL/","text":"El lenguaje de control de transacciones (TCL) Las transacciones Cuando se debe llevar a cabo un conjunto de sentencias de definici\u00f3n (DDL) o de manipulaci\u00f3n de datos (DML) que est\u00e1n estrechamente ligadas entre s\u00ed, ser\u00e1 necesario que se ejecuten como si se tratara de una sola sentencia. Si todas se pueden ejecutar satisfactoriamente, entonces la transacci\u00f3n se dar\u00e1 por finalizada y se validar\u00e1n los cambios realizados en la base de datos. En caso contrario, ser\u00e1 necesario deshacer todos los cambios y dejar la base de datos como si ninguna de las sentencias se hubiera ejecutado. Ejemplo de transacci\u00f3n: Por ejemplo, si se quiere comprar una entrada para un espect\u00e1culo en un portal web, primero ser\u00e1 necesario mostrar cu\u00e1ntas entradas quedan libres, los asientos disponibles y los precios, y permitir que el usuario elija cu\u00e1l le interesa. Si finalmente el usuario decide comprar determinados asientos, el sistema deber\u00e1: Validar que el pago ha sido correcto Marcar los asientos como ocupados Reducir el n\u00famero total de asientos disponibles Si durante este proceso alguna de las sentencias de manipulaci\u00f3n de datos no se ejecutara correctamente, el sistema quedar\u00eda inconsistente (por ejemplo, no coincidir\u00edan los asientos ocupados con el total disponible). Por esta raz\u00f3n, es necesario garantizar que o bien se ejecutan todas las sentencias o no se ejecuta ninguna. Definir una transacci\u00f3n Una transacci\u00f3n es un conjunto de instrucciones que forman una unidad l\u00f3gica de trabajo, una unidad at\u00f3mica que se garantiza que se ejecutar\u00e1 completamente o no se ejecutar\u00e1. Inicio de transacci\u00f3n Para delimitar las instrucciones que forman parte de una transacci\u00f3n, se puede comenzar con la primera orden SQL o utilizar: BEGIN o START TRANSACTION Esto indicar\u00e1 que todo lo que aparezca a continuaci\u00f3n hasta encontrar la sentencia de finalizaci\u00f3n se considerar\u00e1 una unidad at\u00f3mica. Nada de lo que est\u00e9 despu\u00e9s del BEGIN tendr\u00e1 ejecuci\u00f3n f\u00edsica hasta que se llegue al final de la transacci\u00f3n. De esta manera se garantiza que, en caso de fallo del sistema (disco lleno, corte de energ\u00eda, fallo de hardware, etc.), la base de datos se ver\u00e1 alterada por todas las sentencias o por ninguna . Fin de la transacci\u00f3n Las dos sentencias que pueden finalizar una transacci\u00f3n son: 1. Confirmar la transacci\u00f3n (guardar los cambios) COMMIT : Esta sentencia ejecutar\u00e1 todas las sentencias incluidas en la transacci\u00f3n en el orden establecido. Despu\u00e9s de su ejecuci\u00f3n, se podr\u00e1 iniciar una nueva transacci\u00f3n. Sintaxis: COMMIT [WORK | TRANSACTION] (La palabra WORK es opcional) 2.Deshacer la transacci\u00f3n (revertir los cambios) ROLLBACK : Permite deshacer las operaciones realizadas que a\u00fan no se han confirmado con COMMIT.Se pueden revertir operaciones como: INSERT , UPDATE , DELETE . Al ejecutar ROLLBACK, se deshar\u00e1n todas las modificaciones realizadas hasta el \u00faltimo estado estable. Es equivalente al bot\u00f3n \"Deshacer\" (UNDO) en programas ofim\u00e1ticos. Sintaxis: ROLLBACK [WORK | TRANSACTION] [SAVEPOINT savepointname] (La palabra WORK es opcional) Puntos de seguridad (SAVEPOINT) Un SAVEPOINT permite un control m\u00e1s preciso de las transacciones. Permite marcar puntos intermedios dentro de la transacci\u00f3n para poder hacer un ROLLBACK hasta ese punto y no necesariamente hasta el inicio. As\u00ed: Las modificaciones se realizan de forma l\u00f3gica No se hacen f\u00edsicas hasta el COMMIT Se pueden descartar con ROLLBACK \u00bfQu\u00e9 sucede si una transacci\u00f3n no finaliza? Si se llega al final del programa sin ejecutar COMMIT ni ROLLBACK, la norma no especifica qu\u00e9 ocurre. Depender\u00e1 del sistema gestor de bases de datos. Ejemplo de transacci\u00f3n : Supongamos una base de datos con las tablas Proveedores y Productos. Si un proveedor cierra su empresa, ser\u00e1 necesario eliminar: El proveedor Sus productos asociados Esto puede hacerse as\u00ed: BEGIN TRANSACTION DELETE FROM Proveedores WHERE PK_Codigo_Proveedor = 3 DELETE FROM Productos WHERE FK_Proveedor = 3 COMMIT TRANSACTION Si ocurriera un fallo del sistema despu\u00e9s del primer DELETE y no se hubieran usado transacciones, el proveedor se habr\u00eda eliminado pero los productos seguir\u00edan existiendo incorrectamente en la base de datos.","title":"2. TCL"},{"location":"2-TCL/#el-lenguaje-de-control-de-transacciones-tcl","text":"","title":"El lenguaje de control de transacciones (TCL)"},{"location":"2-TCL/#las-transacciones","text":"Cuando se debe llevar a cabo un conjunto de sentencias de definici\u00f3n (DDL) o de manipulaci\u00f3n de datos (DML) que est\u00e1n estrechamente ligadas entre s\u00ed, ser\u00e1 necesario que se ejecuten como si se tratara de una sola sentencia. Si todas se pueden ejecutar satisfactoriamente, entonces la transacci\u00f3n se dar\u00e1 por finalizada y se validar\u00e1n los cambios realizados en la base de datos. En caso contrario, ser\u00e1 necesario deshacer todos los cambios y dejar la base de datos como si ninguna de las sentencias se hubiera ejecutado. Ejemplo de transacci\u00f3n: Por ejemplo, si se quiere comprar una entrada para un espect\u00e1culo en un portal web, primero ser\u00e1 necesario mostrar cu\u00e1ntas entradas quedan libres, los asientos disponibles y los precios, y permitir que el usuario elija cu\u00e1l le interesa. Si finalmente el usuario decide comprar determinados asientos, el sistema deber\u00e1: Validar que el pago ha sido correcto Marcar los asientos como ocupados Reducir el n\u00famero total de asientos disponibles Si durante este proceso alguna de las sentencias de manipulaci\u00f3n de datos no se ejecutara correctamente, el sistema quedar\u00eda inconsistente (por ejemplo, no coincidir\u00edan los asientos ocupados con el total disponible). Por esta raz\u00f3n, es necesario garantizar que o bien se ejecutan todas las sentencias o no se ejecuta ninguna.","title":"Las transacciones"},{"location":"2-TCL/#definir-una-transaccion","text":"Una transacci\u00f3n es un conjunto de instrucciones que forman una unidad l\u00f3gica de trabajo, una unidad at\u00f3mica que se garantiza que se ejecutar\u00e1 completamente o no se ejecutar\u00e1.","title":"Definir una transacci\u00f3n"},{"location":"2-TCL/#inicio-de-transaccion","text":"Para delimitar las instrucciones que forman parte de una transacci\u00f3n, se puede comenzar con la primera orden SQL o utilizar: BEGIN o START TRANSACTION Esto indicar\u00e1 que todo lo que aparezca a continuaci\u00f3n hasta encontrar la sentencia de finalizaci\u00f3n se considerar\u00e1 una unidad at\u00f3mica. Nada de lo que est\u00e9 despu\u00e9s del BEGIN tendr\u00e1 ejecuci\u00f3n f\u00edsica hasta que se llegue al final de la transacci\u00f3n. De esta manera se garantiza que, en caso de fallo del sistema (disco lleno, corte de energ\u00eda, fallo de hardware, etc.), la base de datos se ver\u00e1 alterada por todas las sentencias o por ninguna .","title":"Inicio de transacci\u00f3n"},{"location":"2-TCL/#fin-de-la-transaccion","text":"Las dos sentencias que pueden finalizar una transacci\u00f3n son: 1. Confirmar la transacci\u00f3n (guardar los cambios) COMMIT : Esta sentencia ejecutar\u00e1 todas las sentencias incluidas en la transacci\u00f3n en el orden establecido. Despu\u00e9s de su ejecuci\u00f3n, se podr\u00e1 iniciar una nueva transacci\u00f3n. Sintaxis: COMMIT [WORK | TRANSACTION] (La palabra WORK es opcional) 2.Deshacer la transacci\u00f3n (revertir los cambios) ROLLBACK : Permite deshacer las operaciones realizadas que a\u00fan no se han confirmado con COMMIT.Se pueden revertir operaciones como: INSERT , UPDATE , DELETE . Al ejecutar ROLLBACK, se deshar\u00e1n todas las modificaciones realizadas hasta el \u00faltimo estado estable. Es equivalente al bot\u00f3n \"Deshacer\" (UNDO) en programas ofim\u00e1ticos. Sintaxis: ROLLBACK [WORK | TRANSACTION] [SAVEPOINT savepointname] (La palabra WORK es opcional)","title":"Fin de la transacci\u00f3n"},{"location":"2-TCL/#puntos-de-seguridad-savepoint","text":"Un SAVEPOINT permite un control m\u00e1s preciso de las transacciones. Permite marcar puntos intermedios dentro de la transacci\u00f3n para poder hacer un ROLLBACK hasta ese punto y no necesariamente hasta el inicio. As\u00ed: Las modificaciones se realizan de forma l\u00f3gica No se hacen f\u00edsicas hasta el COMMIT Se pueden descartar con ROLLBACK \u00bfQu\u00e9 sucede si una transacci\u00f3n no finaliza? Si se llega al final del programa sin ejecutar COMMIT ni ROLLBACK, la norma no especifica qu\u00e9 ocurre. Depender\u00e1 del sistema gestor de bases de datos. Ejemplo de transacci\u00f3n : Supongamos una base de datos con las tablas Proveedores y Productos. Si un proveedor cierra su empresa, ser\u00e1 necesario eliminar: El proveedor Sus productos asociados Esto puede hacerse as\u00ed: BEGIN TRANSACTION DELETE FROM Proveedores WHERE PK_Codigo_Proveedor = 3 DELETE FROM Productos WHERE FK_Proveedor = 3 COMMIT TRANSACTION Si ocurriera un fallo del sistema despu\u00e9s del primer DELETE y no se hubieran usado transacciones, el proveedor se habr\u00eda eliminado pero los productos seguir\u00edan existiendo incorrectamente en la base de datos.","title":"Puntos de seguridad (SAVEPOINT)"},{"location":"2.1-Practica/","text":"\ud83e\uddea PR\u00c1CTICA: Gesti\u00f3n de Transacciones con TCL \ud83c\udfaf Objetivo Aprender a: Utilizar BEGIN / START TRANSACTION Aplicar COMMIT Aplicar ROLLBACK Usar SAVEPOINT Entender la importancia de la atomicidad en bases de datos \ud83d\uddc2\ufe0f Contexto Trabajaremos con una base de datos de ventas de entradas de cine . Cuando un cliente compra una entrada, deben realizarse varias acciones: Registrar la compra Marcar el asiento como ocupado Reducir el n\u00famero de asientos disponibles \u26a0\ufe0f Todo esto debe hacerse como una \u00fanica unidad l\u00f3gica. \ud83c\udfd7\ufe0f PREPARACI\u00d3N Crear tablas CREATE TABLE Sesiones ( id_sesion INT PRIMARY KEY , pelicula VARCHAR ( 50 ), asientos_disponibles INT ); CREATE TABLE Asientos ( id_asiento INT PRIMARY KEY , id_sesion INT , ocupado BOOLEAN ); CREATE TABLE Ventas ( id_venta INT PRIMARY KEY , id_sesion INT , id_asiento INT ); Insertar datos iniciales INSERT INTO Sesiones VALUES ( 1 , 'Avatar 3' , 5 ); INSERT INTO Asientos VALUES ( 1 , 1 , false ), ( 2 , 1 , false ), ( 3 , 1 , false ), ( 4 , 1 , false ), ( 5 , 1 , false ); \ud83e\udde9 PARTE 1 \u2014 Sin Transacci\u00f3n (Para ver el problema) Simular una compra SIN transacci\u00f3n: INSERT INTO Ventas VALUES ( 1 , 1 , 2 ); UPDATE Asientos SET ocupado = true WHERE id_asiento = 2 ; -- Simular fallo (NO ejecutar la siguiente l\u00ednea) UPDATE Sesiones SET asientos_disponibles = asientos_disponibles - 1 WHERE id_sesion = 1 ; Consultar el estado: SELECT * FROM Sesiones ; SELECT * FROM Asientos ; SELECT * FROM Ventas ; \ud83d\udccc Pregunta: \u00bfEs consistente la base de datos? \ud83e\udde9 PARTE 2 \u2014 Uso de BEGIN + COMMIT START TRANSACTION ; INSERT INTO Ventas VALUES ( 2 , 1 , 3 ); UPDATE Asientos SET ocupado = true WHERE id_asiento = 3 ; UPDATE Sesiones SET asientos_disponibles = asientos_disponibles - 1 WHERE id_sesion = 1 ; COMMIT ; Consultar resultados: SELECT * FROM Sesiones ; SELECT * FROM Asientos ; SELECT * FROM Ventas ; \ud83e\udde9 PARTE 3 \u2014 Uso de ROLLBACK Simular un error: START TRANSACTION ; INSERT INTO Ventas VALUES ( 3 , 1 , 4 ); UPDATE Asientos SET ocupado = true WHERE id_asiento = 4 ; -- ERROR SIMULADO \u2192 sesi\u00f3n no existe UPDATE Sesiones SET asientos_disponibles = asientos_disponibles - 1 WHERE id_sesion = 99 ; ROLLBACK ; Consultar: SELECT * FROM Sesiones ; SELECT * FROM Asientos ; SELECT * FROM Ventas ; \ud83d\udccc Pregunta: \u00bfSe ha realizado alguna modificaci\u00f3n? \ud83e\udde9 PARTE 4 \u2014 Uso de SAVEPOINT START TRANSACTION ; INSERT INTO Ventas VALUES ( 4 , 1 , 5 ); SAVEPOINT venta_realizada ; UPDATE Asientos SET ocupado = true WHERE id_asiento = 5 ; SAVEPOINT asiento_actualizado ; -- ERROR SIMULADO UPDATE Sesiones SET asientos_disponibles = asientos_disponibles - 1 WHERE id_sesion = 99 ; ROLLBACK TO asiento_actualizado ; COMMIT ; Consultar: SELECT * FROM Sesiones ; SELECT * FROM Asientos ; SELECT * FROM Ventas ; \ud83d\udccc Pregunta: \u00bfQu\u00e9 cambios se han guardado? \ud83e\udde0 PARTE 5 \u2014 Reflexi\u00f3n Responder: \u00bfQu\u00e9 ventaja tienen las transacciones? \u00bfQu\u00e9 ocurrir\u00eda en un sistema real sin ellas? \u00bfQu\u00e9 diferencia hay entre ROLLBACK y ROLLBACK TO SAVEPOINT? \u00bfEn qu\u00e9 situaciones reales usar\u00edas SAVEPOINT? \ud83c\udfc1 RETO FINAL Crear una transacci\u00f3n que: Venda 2 entradas a la vez Si falla una, no se venda ninguna","title":"2.1 Pr\u00e1ctica"},{"location":"2.1-Practica/#practica-gestion-de-transacciones-con-tcl","text":"","title":"\ud83e\uddea PR\u00c1CTICA: Gesti\u00f3n de Transacciones con TCL"},{"location":"2.1-Practica/#objetivo","text":"Aprender a: Utilizar BEGIN / START TRANSACTION Aplicar COMMIT Aplicar ROLLBACK Usar SAVEPOINT Entender la importancia de la atomicidad en bases de datos","title":"\ud83c\udfaf Objetivo"},{"location":"2.1-Practica/#contexto","text":"Trabajaremos con una base de datos de ventas de entradas de cine . Cuando un cliente compra una entrada, deben realizarse varias acciones: Registrar la compra Marcar el asiento como ocupado Reducir el n\u00famero de asientos disponibles \u26a0\ufe0f Todo esto debe hacerse como una \u00fanica unidad l\u00f3gica.","title":"\ud83d\uddc2\ufe0f Contexto"},{"location":"2.1-Practica/#preparacion","text":"","title":"\ud83c\udfd7\ufe0f PREPARACI\u00d3N"},{"location":"2.1-Practica/#crear-tablas","text":"CREATE TABLE Sesiones ( id_sesion INT PRIMARY KEY , pelicula VARCHAR ( 50 ), asientos_disponibles INT ); CREATE TABLE Asientos ( id_asiento INT PRIMARY KEY , id_sesion INT , ocupado BOOLEAN ); CREATE TABLE Ventas ( id_venta INT PRIMARY KEY , id_sesion INT , id_asiento INT );","title":"Crear tablas"},{"location":"2.1-Practica/#insertar-datos-iniciales","text":"INSERT INTO Sesiones VALUES ( 1 , 'Avatar 3' , 5 ); INSERT INTO Asientos VALUES ( 1 , 1 , false ), ( 2 , 1 , false ), ( 3 , 1 , false ), ( 4 , 1 , false ), ( 5 , 1 , false );","title":"Insertar datos iniciales"},{"location":"2.1-Practica/#parte-1-sin-transaccion-para-ver-el-problema","text":"Simular una compra SIN transacci\u00f3n: INSERT INTO Ventas VALUES ( 1 , 1 , 2 ); UPDATE Asientos SET ocupado = true WHERE id_asiento = 2 ; -- Simular fallo (NO ejecutar la siguiente l\u00ednea) UPDATE Sesiones SET asientos_disponibles = asientos_disponibles - 1 WHERE id_sesion = 1 ; Consultar el estado: SELECT * FROM Sesiones ; SELECT * FROM Asientos ; SELECT * FROM Ventas ; \ud83d\udccc Pregunta: \u00bfEs consistente la base de datos?","title":"\ud83e\udde9 PARTE 1 \u2014 Sin Transacci\u00f3n (Para ver el problema)"},{"location":"2.1-Practica/#parte-2-uso-de-begin-commit","text":"START TRANSACTION ; INSERT INTO Ventas VALUES ( 2 , 1 , 3 ); UPDATE Asientos SET ocupado = true WHERE id_asiento = 3 ; UPDATE Sesiones SET asientos_disponibles = asientos_disponibles - 1 WHERE id_sesion = 1 ; COMMIT ; Consultar resultados: SELECT * FROM Sesiones ; SELECT * FROM Asientos ; SELECT * FROM Ventas ;","title":"\ud83e\udde9 PARTE 2 \u2014 Uso de BEGIN + COMMIT"},{"location":"2.1-Practica/#parte-3-uso-de-rollback","text":"Simular un error: START TRANSACTION ; INSERT INTO Ventas VALUES ( 3 , 1 , 4 ); UPDATE Asientos SET ocupado = true WHERE id_asiento = 4 ; -- ERROR SIMULADO \u2192 sesi\u00f3n no existe UPDATE Sesiones SET asientos_disponibles = asientos_disponibles - 1 WHERE id_sesion = 99 ; ROLLBACK ; Consultar: SELECT * FROM Sesiones ; SELECT * FROM Asientos ; SELECT * FROM Ventas ; \ud83d\udccc Pregunta: \u00bfSe ha realizado alguna modificaci\u00f3n?","title":"\ud83e\udde9 PARTE 3 \u2014 Uso de ROLLBACK"},{"location":"2.1-Practica/#parte-4-uso-de-savepoint","text":"START TRANSACTION ; INSERT INTO Ventas VALUES ( 4 , 1 , 5 ); SAVEPOINT venta_realizada ; UPDATE Asientos SET ocupado = true WHERE id_asiento = 5 ; SAVEPOINT asiento_actualizado ; -- ERROR SIMULADO UPDATE Sesiones SET asientos_disponibles = asientos_disponibles - 1 WHERE id_sesion = 99 ; ROLLBACK TO asiento_actualizado ; COMMIT ; Consultar: SELECT * FROM Sesiones ; SELECT * FROM Asientos ; SELECT * FROM Ventas ; \ud83d\udccc Pregunta: \u00bfQu\u00e9 cambios se han guardado?","title":"\ud83e\udde9 PARTE 4 \u2014 Uso de SAVEPOINT"},{"location":"2.1-Practica/#parte-5-reflexion","text":"Responder: \u00bfQu\u00e9 ventaja tienen las transacciones? \u00bfQu\u00e9 ocurrir\u00eda en un sistema real sin ellas? \u00bfQu\u00e9 diferencia hay entre ROLLBACK y ROLLBACK TO SAVEPOINT? \u00bfEn qu\u00e9 situaciones reales usar\u00edas SAVEPOINT?","title":"\ud83e\udde0 PARTE 5 \u2014 Reflexi\u00f3n"},{"location":"2.1-Practica/#reto-final","text":"Crear una transacci\u00f3n que: Venda 2 entradas a la vez Si falla una, no se venda ninguna","title":"\ud83c\udfc1 RETO FINAL"}]}